# paxos & ratf 算法笔记

## 强一致性-Paxos

### Basic-Paxos

#### 角色介绍

- Client
  - 请求发起者，系统外部角色
- Propser
  - 接受`client`请求，向集群提出建议。起到冲突调节的作用。
- Accpetor
  - 提议投票和接受者，只有在行程法定人数（Quorum）时，提议才会最终被接受。
- Learner
  - 提议接受者，备份，对集群一致性没有影响（不参与投票）。

#### 步骤和阶段

- Prepare
  - `Proposer`提出一个提案，编号为 N，此 N 大于这个`Proposer`之前提出提案编号，请求`Accpetors`的`quorum`接受。
- Promise
  - 如果 N 大于此`accpetor`之前接受的任何提案编号则接受，否则拒绝。
- Accept
  - 如果达到了多数派，`proposer`会发出`accept`请求，此请求包含提案 N，以及内容。
- Accepted
  - 如果此`acceptor`在此期间没有收到任何大于 N 的提案，则接收此提案内容，否则忽略。



### Multi-Paxos

在下面的图中，只显示了基本Paxos协议的一个实例(或“执行”)和一个初始Leader(Proposer)。注意，Multi-Paxos使用几个Basic Paxos的实例。

```
Client   Proposer      Acceptor     Learner
   |         |          |  |  |       |  | --- First Request ---
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Prepare(N)
   |         |<---------X--X--X       |  |  Promise(N,I,{Va,Vb,Vc})
   |         X--------->|->|->|       |  |  Accept!(N,I,V)
   |         |<---------X--X--X------>|->|  Accepted(N,I,V)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |
```



```
Client   Proposer       Acceptor     Learner
   |         |          |  |  |       |  |  --- Following Requests ---
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Accept!(N,I+1,W)
   |         |<---------X--X--X------>|->|  Accepted(N,I+1,W)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |
```



## Ratf

### 重新定义角色

- Leader
- Follower
- Candidate

###  节点状态

节点可以有三种状态，跟随者状态、候选人状态、领导者状态

所有节点从跟随者状态开始，如果跟随者没有收到领导者的来信，那么它就变成候选人状态；

候选人从其他节点请求投票，其他节点将投票表决，如果从多数节点中获取投票，那么此候选人将成为领导者。这个过程就是领导人选举。

现在所有系统的更改都要通过领导者。



### 日志复制

当选取领导人之后，每次系统的更改都将添加一个条目到当前节点的日志中。

当日志条目未提交前，领导者是不会更改当前节点的信息。如果要提交条目，领导者首先要将日志中新添加的条目**复制**到其跟随节点，然后领导者等待，子节点收到消息后将其添加到条目，并**发送反馈消息**给领导者，直到领导者接到大多数节点都添加了该条目，然后该条目会提交到领导者节点上，并更改节点状态。然后领导者**通知**跟随者该条目已经提交，然后跟随者也提交并更改节点状态。到这里集群系统的所有状态就达成了共识。



当选出一位领导者后，我们需要将系统的所有更改复制到所有节点，通过使用与心跳相同的“添加条目”消息来完成此操作。

#### 举例：

首先，客户端**发送**更改状态消息给领导者，然后领导者将其添加到领导者的日志中，然后将更改在下一次心跳发送给追随者。一旦大多数追随者**认可**，便提交该条目，并且**响应**给客户端，然后发送一条消息给追随者，让其改变状态。

#### 网络分区问题

假设一共有 5 个结点，分别是 A~E，最开始是由 B 作为领导者，然后将 AB 与 CDE 三个结点隔离，发送一个更改消息给 A，赋值为 5，然后 A 发送消息给追随者，由于 AB 被单独隔离，无法发送到 CDE，所以 A 无法得到大多数追随者认可，所以无法提交，AB 保持着未提交状态。并且由于未提交并不会响应给客户端。

在 CDE 中由于长时间没有接受到心跳检测，所以在其中选取了 C 作为领导者，现在发送一个消息给 C 赋值为 8，C 再发送消息给 DE，得到包括自己有 3 票，响应客户端，然后改变状态为 8。

然后修复网络分区，同时 A 和 C 都是领导者，但是由于 C 的期号更大（C 相比于 A 要晚选举出来，期号递增），所有 A 自动退出为追随者。节点 A 和 B 回滚到未提交状态。并且同步到最新状态 C 的日志。





#### 问题

1. 在分区的时候，由于 A 没有得到大多数的投票，所以没有提交，当发现期号更大的领导者，并退回到追随者的时候，将回退此提交，那之前客户端提交的消息就不要了吗？
2. 领导者发送的心跳检测一直都包含复制日志消息吗？当分区结束后，老的领导者 A 就立即同步了 C 的最新日志，或者是新的领导者检测到了有节点没有同步新的节点，它才发送的？但是这个检测是如何检测的？如果一直都包含日志同步信息，如果日志量大了，这是不是很耗性能？
3. 期号是全局性的，如何保证期号在全局一致性？
4. 如何发送 rpc 出现丢包等网络问题无法发送到追随者，然后追随者变成了了候选人，然后这个候选人的期号比领导人大，然后这个时候网络问题修复，候选人的期号比领导人大（好像是成为候选人就有期号了），领导人会不会退位。还要就是候选人这个时候发送投票，在当前期号追随者是没有投过票的，追随者会不会投票然后候选者变成领导者？
5. 候选人发送消息给追随者，如果没有投票就给这个候选人投票，如何判断追随者是否投过票？这个判断的依据是什么？
6. 在同一个期号只能投票一次，如何有多个候选人同时发起投票，导致第一次投票不成功要进行下一轮的投票，这个那么在这个期号内，其他节点还能如何投票？





### 领导人选举

#### 选举超时

> 选举超时是指追随者成为候选人之前的等待时间，选举超时被随机分配在 150 毫秒至 300 毫秒之间。

在选举超时后，追随者变成了候选者，并开始一个新的选举时期。先为自己投票，并将**请求投票**消息发送给其他节点，如果接受节点在这个时期还没有投票，那么它将**投票投给**候选人，并且节点重置其选举超时。

一旦候选人获得多数投票，它就会变成领导者。领导者开始向其追随者**发送**“添加条目”消息。这些消息以**心跳超时**指定时间间隔发送。追随者响应每个追加条目的消息，将选举超时时间清零。这个阶段将持续到追随者停止接受心跳并成为候选人为止。

如果此时领导者失效（停止发送心跳检测），当追随者中一个选举超时时间到达，成为了候选者并获得多数投票成为领导者，想重复之前领导者做的事情。

如果两个节点同时成为候选节点，则可能会发生拆分表决，可能会经历多个选举超时时期，最终选取一个获取多数投票的候选者成为领导者。

