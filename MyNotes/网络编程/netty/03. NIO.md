# NIO

### NIO 非阻塞 网络编程原理分析图

NIO 非阻塞 网络编程相关的（Selector、SelectorKey、ServerSocketChannel 和 SocketChannel）关系梳理图。

![image-20200730095226983](https://tva1.sinaimg.cn/large/007S8ZIlly1gh8tjhsgiwj30va0hkju5.jpg)

#### 对上图说明：

1. 当客户端连接时，会通过 ServerSocketChannel 得到 SocketChannel
2. Selector 进行监听，select 方法，返回有事件发生的通道的个数。
3. 将 SocketChannel 注册到 Selector 上，register(Selector sel, int ops)，一个 Selector 上可以注册多个 SocketChannel
4. 注册后返回一个 SelectionKey，会和该 Selector 向关联（集合）
5. 进一步得到各个 SelectionKey（由事件发生的）
6. 再通过SelectionKey反向得到 SocketChannel。
7. 通过获得的channel，完成业务处理。



#### 实例

服务端代码

```java
package cn.personalweb.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

/**
 * @program: netty
 * @description: NIO 服务端, 注册到 Selector
 * @author: lizheng
 * @create: 2020-07-30 10:19
 **/
public class NIOServer {
    public static void main(String[] args) throws IOException {
        // 创建 ServerSocketChannel, 得到 SocketChannel
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

        // 创建 Selector 对象
        Selector selector = Selector.open();

        // 绑定一个端口,在服务器监听
        serverSocketChannel.socket().bind(new InetSocketAddress(6666));

        // 设置为非阻塞
        serverSocketChannel.configureBlocking(false);

        // 把 ServerSocketChannel 注册到 Selector 关心事件为 OP_ACCEPT
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        // 循环监听, 等待客户端连接

        while (true) {
            // 如果等待 1 秒都没有时间发生, 返回
            if (selector.select(1000) == 0) {
                System.out.println("服务器等待 1 秒, 无客户端连接");
                continue;

            }

            // 如果返回 >0, 就获取到相关的 SelectionKey 集合
            // 1. 如果返回的 >0, 表示已获取到关注的事件
            // 2. Selector.selectedKeys() 返回关注事件的集合
            // 通过 selectionKeys 发娘获取通道
            Set<SelectionKey> selectionKeys = selector.selectedKeys();
            Iterator<SelectionKey> keyIterator = selectionKeys.iterator();

            while (keyIterator.hasNext()){
                // 获取到 SelectionKey
                SelectionKey selectionKey = keyIterator.next();
                // 根据 key 对应的通道发生等待时间做相应的处理
                if (selectionKey.isAcceptable()) {
                    // 该客户端生成一个 SocketChannel
                    SocketChannel socketChannel = serverSocketChannel.accept();
                    System.out.println("客户端连接成功, 生成一个 SocketChannel" + socketChannel.hashCode());

                    // 将SocketChannel设置为非阻塞的
                    socketChannel.configureBlocking(false);

                    // 将当前的 SocketChannel 注册到 selector, 关注事件为OP_READ, 同时给 SocketChannel
                    // 关联一个 Buffer
                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024));
                }
                if (selectionKey.isReadable()) {
                    // 发生 OP_READ
                    SocketChannel channel = (SocketChannel) selectionKey.channel();
                    // 获取到该 channel 关联的 buffer
                    ByteBuffer buffer = (ByteBuffer)selectionKey.attachment();
                    channel.read(buffer);
                    System.out.println("from 客户端" + new String(buffer.array()));

                }
                // 手动从集合中移出当前的 SelectionKey, 防止重复操作
                keyIterator.remove();
            }
        }

    }
}

```

客户端代码

```java
package cn.personalweb.nio;

import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

/**
 * @program: netty
 * @description: NIO 客户端, NIO 实例
 * @author: lizheng
 * @create: 2020-07-30 11:06
 **/
public class NIOClient {
    public static void main(String[] args) throws Exception{
        // 得到一个网络通道
        SocketChannel socketChannel = SocketChannel.open();
        // 设置非阻塞
        socketChannel.configureBlocking(false);

        // 提供服务的 ip 地址和端口
        InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1", 6666);

        // 连接服务器
        if (!socketChannel.connect(inetSocketAddress)) {

            while (!socketChannel.finishConnect()) {
                System.out.println("因为连接需要时间, 客户端不会阻塞,可以做其他工作");
            }

            // 如果连接成功, 就发送数据
            String str = "hello, my first NIO";
            // 无需指定自己大小, 根据输入的大小自动包裹
            ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());
            // 发送数据, 将 buffer数据写入
            socketChannel.write(buffer);
            System.in.read();

        }
    }
}

```



### SelectionKey

1. SelectionKey 表示 Selector 和网络通道的注册关系，共四种：

   - `public static final int OP_READ = 1 << 0;`**OP_READ**：代表读操作，值为 1
   - `public static final int OP_WRITE = 1 << 2;`**OP_WRITE**，代表科写操作，值为 4
   - `public static final int OP_CONNECT = 1 << 3;`**OP_CONNECT**，代表连接已建立，值为 8
   - `public static final int OP_ACCEPT = 1 << 4;`：**OP_ACCEPT**：有新的网络连接可以 `accept`，值为 16；

2. SelectionKey 相关方法

   ```java
   public abstract Selector selector();	// 得到与之关联的 Selector
   
   public abstract SelectableChannel channel();	// 得到与之关联的通道
   
   public final Object attachment();	// 得到与之关联的共享数据(buffer)
   
   public abstract int interestOps();	// 设置或改变监听事件 SelectionKey.OP_READ。。。
   
   public final boolean isAcceptable();	// 是否可以 accept
   
   public final boolean isReadable();	// 是否可以读
   
   public final boolean isWritable();	// 是否可以写
   
   ```



### ServerSocketChannel

1. `ServerSocketChannel`在服务器端监听新的客户端 Socket 连接

2. 相关方法如下：

   <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh9y1s0ke6j30og0badpz.jpg" alt="image-20200731102621342" style="zoom:50%;" />



### SocketChannel

1. SocketChannel，网络 IO 通道，具体负责进行读写操作。NIO 把缓存区的数据写入通道，或者把通道里的数据读到缓冲区。

2. 相关方法

   <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh9y6dxo8mj30pw0d4dwd.jpg" alt="image-20200731103050568" style="zoom:50%;" />

