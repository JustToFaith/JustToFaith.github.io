# Java Stream流

### 流式思想概述

从整体上看,流式思想类似于工厂车间的**生产流水线**. 当需要对多个元素进行操作是(特别是多步操作)的时候,考虑到性能及便捷性,我们应该首先拼好一个"模型"步骤方案,然后按照方案去执行它.

> 备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。 

- 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 
- **数据源** 流的来源。 可以是集合，数组 等。

和以前的Collection操作不同， Stream操作还有两个基础的特征： 

- **Pipelining**: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 
- **内部迭代**： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。 

当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。 

### 获取流

`java.util.stream.Stream<T>` 是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）获取一个流非常简单，有以下几种常用的方式：

- 所有的 `Collection` 集合都可以通过 `stream` 默认方法获取流； 
- `Stream` 接口的静态方法 `of` 可以获取数组对应的流。

#### 根据Collection获取流

首先， `java.util.Collection` 接口中加入了default方法 `stream` 用来获取流，所以其所有实现类均可获取流。 

```java
import java.util.*;
import java.util.stream.Stream;

public class DemoGetStream {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        Stream<String> stream1 = list.stream();
         
         
        Set<String> set = new HashSet<>();
        Stream<String> stream2 = set.stream();
         
        Vector<String> vector = new Vector<>();
        Stream<String> stream3 = vector.stream();
    } }
```



#### 根据Map获取流

`java.util.Map` 接口不是 `Collection` 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况： 

```java
import java.util.HashMap; 
import java.util.Map; 
import java.util.stream.Stream; 

public class DemoGetStream { 
    public static void main(String[] args) { 
        Map<String, String> map = new HashMap<>(); 
        // ... 
        Stream<String> keyStream = map.keySet().stream(); 
        Stream<String> valueStream = map.values().stream(); 
        Stream<Map.Entry<String, String>> entryStream = map.entrySet().stream(); 
    } 
}
```



#### 根据数组获取流

如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法`of` ，使用很简单：

```java
import java.util.stream.Stream; 

public class DemoGetStream { 
    public static void main(String[] args) { 
        String[] array = { "张无忌", "张翠山", "张三丰", "张一元" }; 
        Stream<String> stream = Stream.of(array); 
    } 
}
```

> 备注： of 方法的参数其实是一个可变参数，所以支持数组。 



### 常用方法

流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种： 

- **延迟方法**：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。） 
- **终结方法**：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调用。本小节中，终结方法包括 count 和 forEach 方法。 

> 备注：更多方法，参考API文档。

#### 逐一处理:forEach

虽然方法名字叫`forEach` ，但是与for循环中的“for-each”昵称不同。

```java
void forEach(Consumer<? super T> action);
```

该方法接收一个 `Consumer` 接口函数，会将每一个流元素交给该函数进行处理。 

##### 复习Consumer接口

```java
java.util.function.Consumer<T>接口是一个消费型接口。 
Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。
```

##### 基本使用

```java
import java.util.stream.Stream; 
public class DemoStreamForEach { 
    public static void main(String[] args) { 
        Stream<String> stream = Stream.of("张无忌", "张三丰", "周芷若"); 
        stream.forEach(name‐> System.out.println(name)); 
    } 
}
```

#### 过滤:filter

可以通过 `filter` 方法将一个流转换成另一个子集流。方法签名： 

```java
Stream<T> filter(Predicate<? super T> predicate);
```

该接口接收一个 `Predicate` 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。 

##### 复习Predicate接口

此前我们已经学习过 `java.util.stream.Predicate` 函数式接口，其中唯一的抽象方法为：

```java
boolean test(T t);
```

该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 `filter` 方法将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。 

##### **基本使用** 

Stream流中的 `filter` 方法基本使用的代码如：

```java
import java.util.stream.Stream; 
public class DemoStreamFilter { 
    public static void main(String[] args) { 
        Stream<String> original = Stream.of("张无忌", "张三丰", "周芷若"); 
        Stream<String> result = original.filter(s ‐> s.startsWith("张")); 
    } 
}
```

在这里通过Lambda表达式来指定了筛选的条件：必须姓张。



#### 映射:map

如果需要将流中的元素映射到另一个流中，可以使用 `map` 方法。方法签名： 

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper);
```

该接口需要一个 `Function` 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 

##### 复习Function接口

此前我们已经学习过 `java.util.stream.Function` 函数式接口，其中唯一的抽象方法为： 

```java
R apply(T t);
```

这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。 

##### **基本使用**

Stream流中的 `map` 方法基本使用的代码如： 

```java
import java.util.stream.Stream; 
public class Demo08StreamMap { 
    public static void main(String[] args) { 
        Stream<String> original = Stream.of("10", "12", "18"); 
        Stream<Integer> result = original.map(str‐>Integer.parseInt(str)); 
    } 
}
```

这段代码中， `map` 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对象）。

#### 统计个数:count

正如旧集合 `Collection` 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数： 

```java
long count();
```

该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。

##### 基本使用： 

```java
import java.util.stream.Stream; 
public class DemoStreamCount { 
    public static void main(String[] args) { 
        Stream<String> original = Stream.of("张无忌", "张三丰", "周芷若"); 
        Stream<String> result = original.filter(s ‐> s.startsWith("张")); 
        System.out.println(result.count()); // 2 
        
         } 
}
```

#### 取用前几个：limit

`limit` 方法可以对流进行截取，只取用前n个。方法签名

```java
Stream<T> limit(long maxSize);
```

参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。

##### 基本使用：

```java
public class DemoStreamLimit { 
    public static void main(String[] args) { 
        Stream<String> original = Stream.of("张无忌", "张三丰", "周芷若"); 
        Stream<String> result = original.limit(2); 
        System.out.println(result.count()); // 2
        
         }
}
```

#### 跳过前几个:skip

如果希望跳过前几个元素，可以使用 `skip` 方法获取一个截取之后的新流： 

```java
Stream<T> skip(long n);
```

如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。

##### 基本使用：

```java
import java.util.stream.Stream; 

public class DemoStreamSkip { 
    public static void main(String[] args) { 
        Stream<String> original = Stream.of("张无忌", "张三丰", "周芷若"); 
        Stream<String> result = original.skip(2); 
        System.out.println(result.count()); // 1 
        
    } 
}
```

#### 组合:concat

如果有两个流，希望合并成为一个流，那么可以使用 `Stream` 接口的静态方法 `concat` ：

```java
static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)
```

> 备注：这是一个静态方法，与 `java.lang.String` 当中的 concat 方法是不同的。 

##### 该方法的基本使用代码如：

```java
import java.util.stream.Stream; 

public class DemoStreamConcat { 
    public static void main(String[] args) { 
        Stream<String> streamA = Stream.of("张无忌"); 
        Stream<String> streamB = Stream.of("张翠山"); 
        Stream<String> result = Stream.concat(streamA, streamB); 
    } 
}
```

