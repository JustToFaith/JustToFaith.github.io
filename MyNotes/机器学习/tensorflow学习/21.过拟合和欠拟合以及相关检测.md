## 过拟合和欠拟合以及相关检测

1. 什么是过拟合和欠拟合

   欠拟合是指模型的拟合度不高，数据距离拟合曲线较远，或指模型没有很好地捕捉到数据特征，不能很好地拟合数据。过拟合是指对于训练的数据拟合度太高，过度地拟合了数据特征导致在测试集中误差太大。

   ​		过拟合可以举个例子，比如我们在考试前刷大量的题，我们死记硬背知道了掌握了题型的解法。但是到了考试中如果我们遇到相识的题型我们可以解出答案，但是如果遇到了我们在考前没有做过的题型或者说在我们做过的题型上做了一些改变，我们就不会做了。这就是在考前刷题的时候太过于记住某一些题的特征导致我们在考试的时候匹配不到相识的特征就不会做。这就是过拟合。

2. 过拟合和欠拟合出现的原因

   欠拟合的原因是特征维度过少，导致拟合的函数无法满足训练集，误差较大。

   过拟合的原因是特征维度过多，导致拟合的函数完美地拟合训练集，但是对新的测试集的不能很好地拟合，预测误差较大，可以理解为它记住了训练集的特征，但是对未知的测试集不能有很好的预测。



#### 过拟合的检测

1. 交叉验证

   两种划分，训练和验证

   ```pythn
   (x, y), (x_val, y_val) = datasets.mnist.load_data()
   
   db = tf.data.Dataset.from_tensor_slices((x, y))
   db = db.map(preprocess).shuffle(10000).batch(128)
   
   ds_val= tf.data.Dataset.from_tensor_slices((x_val, y_val))
   ds_val = ds_val.map(preprocess).batch(128)
   
   ```

   三种划分，训练、验证和测试

   ```python
   (x, y), (x_test, y_test) = datasets.mnist.load_data()
   
   x_train, x_val = tf.split(x, num_or_size_splits=[50000, 10000])
   y_train, y_val = tf.split(x, num_or_size_splits=[50000, 10000])
   
   db_train = tf.data.Dataset.from_tensor_slices((x_train, y_train))
   db_train = db_train.map(preprocess).shuffle(50000).batch(128)
   
   ds_val= tf.data.Dataset.from_tensor_slices((x_val, y_val))
   ds_val = ds_val.map(preprocess).shuffle(10000).batch(128)
   
   ds_test = tf.data.Dataset.from_tensor_slices((x_test, y_test))
   ds_test = ds_test.map(preprocess).batch(128)
   ```

   在训练中验证

   ```python
   network.compile(optimizer=optimizers.Adam(lr=0.01),
   		loss=tf.losses.CategoricalCrossentropy(from_logits=True),
   		metrics=['accuracy']
   	)
   
   network.fit(db, epochs=5, validation_data=db_val, validation_freq=2)
   ```

   在训练后测试

   ```python
   network.evaluate(db_test)
   ```

   **K-fold交叉验证**

   把训练数据划分成N分，每次选择其中一份作为测试集，其余作为训练集

   例如：

   有以下6组数据

   ```
   [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]
   ```

   分为三组

   ```
   Fold1: [0.5, 0.2]
   Fold2: [0.1, 0.3]
   Fold3: [0.4, 0.6]
   ```

   交叉验证的时会使用如下三个模型，分别进行训练和测试，每个测试集误差MSE加和平均就得到了交叉验证的总评分

   ```
   Model1: Trained on Fold1 + Fold2, Tested on Fold3
   Model2: Trained on Fold2 + Fold3, Tested on Fold1
   Model3: Trained on Fold1 + Fold3, Tested on Fold2
   ```

   代码

   ```python
   for epoch in range(500):
       idx = tf.range(6000)
       idx = tf.random.shuffle(idx)
       x_train, y_train = tf.gather(x, idx[:50000]), tf.gather(y, idx[:50000])
       x_val, y_val = tf.gather(y, idx[-10000:]), tf.gather(y, idx[-10000:])
   		
       db = tf.data.Dataset.from_tensor_slices((x, y))
       db = db.map(preprocess).shuffle(10000).batch(128)
   
       ds_val= tf.data.Dataset.from_tensor_slices((x_val, y_val))
       ds_val = ds_val.map(preprocess).batch(128)
       
       # training...
       
       # evalutation...
   ```

   keras中实现

   ```python
   network.fit(db_train_val, epochs=6, validation_split=0.1, validation_freq=2)  # 动态在0.9 和 0.1 之间切割
   ```

   

---

好文：

[过拟合详解](https://www.jiqizhixin.com/articles/2019-01-25-23)

