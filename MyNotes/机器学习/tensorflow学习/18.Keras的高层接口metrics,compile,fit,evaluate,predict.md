## Keras的高层接口metrics,compile,fit,evaluate,predict

#### 我们主要使用的5个接口

- datasets
- layers
- losses
- metrics
- optimizers

#### metrics

这个`API`是一个评估指标算子，可以用于计算平均值、正确率等。我们自己也可以写出相同功能的函数实现此功能，但是TensorFlow提供的api更方便和有效。自己写的函数如果应用到大型数据集，可能会导致数据集太大无法一次性加载到内存中。所以为了能在大型数据集中使用，我们希望使得评估指标能够逐步更新，每次更新一个batch中的预测值和标签。那么metrics就可以实现在跟踪每个batch的指标，然后再释放掉重新跟踪，相对于自己写函数实现此功能会跟容易操作。

1. Build a meter

   ```python
   acc_meter = metrics.Accuracy()
   loss_meter = metrics.Mean()
   ```

2. Update data

   ```python
   loss_meter.update_state(loss)
   acc_meter.update_state(y, pred)  # 真实的y和预测的y
   ```

3. Get Average data

   ```python
   print(step, 'loss:', loss_meter.result().numpy())  # loss_meter.result()得到的是一个Tensor数据，需要把它转换成numpy
   print(step, 'Evaluate Acc:'total_correct/total, acc_meter.result().numpy())
   ```

4. Clear buffer

   ```python
   if step % 100 == 0:
     print(step, 'loss:', loss_meter.result().numpy())
     loss_meter.reset_states()
    
   
   if step % 500 == 0:
     print(step, 'Evaluate Acc:'total_correct/total, acc_meter.result().numpy())
     acc_meter.reset_states()
   ```

#### compile，fit，

`compile`是一个快捷训练方法，类似于一个装载的功能，提供了loss、优化器和评估指标的选择。然后通过`fit`执行标准处理。通过`evaluate`进行测试，再用`predict`进行预测。

```python
network = Sequential([layers.Dense(256, activation='relu'),
                     layers.Dense(128, activation='relu'),
                     layers.Dense(64, activation='relu'),
                     layers.Dense(32, activation='relu'),
                     layers.Dense(10)])
network.build(input_shape=(None, 28*28))

network.compile(optimizer=optimizers.Adam(lr=0.01),
		loss=tf.losses.CategoricalCrossentropy(from_logits=True),
		metrics=['accuracy'])
# 这里指定优化器，loss和测试指标

network.fit(db, epochs=10)  # 这里先对bd进行了一个迭代，然后再进行10次epoch迭代。与之前两个for循环相同
   
# 如果要边训练边测试进行验证，可以用如下方法，validation是验证的意思
network.fit(db, epochs=10, validation_data=ds_val, validation_freq=2)  # validation_data是测试的数据集，validation_freq是每训练两个epoch进行验证一次    

# evaluate 评估                
network.evaluate(ds_val)  # evaluate和validation不同的是validation是在训练过程中测试的，可以看到在训练时的准确率，如果当valudation达到某个指标，例如valuation>0.99时。也可以让程序break，保存参数。
                
# evaluate就是在程序训练结束之后再进行一次评估，最好评估的数据和valudation不一样，这样保证了评估的准确性.

# pred预测
sample = next(iter(ds_val))
x = sample[0]
y = sample[1] # one-hot,  这里为什么就是one-hot？
pred = network.predict(x) # [b, 10]
# 转换到数字
y = tf.argmax(y, axis=1)
pred = tf.argmax(pred, axis=1)

print(pred)
print(y)
```



