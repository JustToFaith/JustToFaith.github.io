

# 三种 I/O 模式

### 简介

|       名称        | JDK 版本                        | 简介               |
| :---------------: | ------------------------------- | ------------------ |
|  BIO（阻塞 I/O）  | JDK 1.4 之前                    | 排队打饭模式       |
| NIO（非阻塞 I/O） | JDK 1.4（2002 年，java.nio 包） | 点单、等待被叫模式 |
|  AIO（异步 I/O）  | JDK 1.7（2011 年）              | 包厢模式           |

#### 阻塞与非阻塞

- 菜没好，要不要死等 -> 数据就绪前要不要等待？

- 阻塞：没有数据传来时，读会阻塞直到有数据；缓冲区满时，写操作也会阻塞。

  非阻塞遇到这些情况，都是直接返回



#### 同步与异步

- 菜好了，谁端 -> 数据就绪后，数据操作谁完成？
- 数据就绪后需要自己去读是同步，数据就绪直接读好再回调给程序是异步。



### Netty 对三种 I/O 模式的支持

![image-20200727101643266](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh5bagwjwuj30ys0fwdhu.jpg)

现在已不再支持 BIO 和 AIO。



### 框架模型

底层由 TCP/IP 协议构成，上面是原生的 JDK I/O 网络，再上面是NIO 网络，最上面封装成 Netty 网络框架

![image-20200727110040689](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh5ck8cr8lj30ey0comxl.jpg)

### BIO

> 同步并阻塞（传统阻塞型），服务器是实现模式为一个连接一个**线程**，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。

存在问题：

1. 每个请求都需要创建一个独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write
2. 当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大
   - 线程是很昂贵的：1. 在 Linux 中，一个线程相当于一个进程，比较耗资源；2. 启动一个线程大概需要耗 512k~1M 的内存资源
3. 连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费



![image-20200727112629309](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh5db5zi8pj30tc0m2qel.jpg)



### NIO

> 同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求就进行处理。

#### 基本介绍

1. Java NIO 全称  **java** **non-blocking** **IO**， 是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进输入/输出的新特性，被统称为 NIO（即 New IO），是同步非阻塞的
2. NIO 相关类都被放在 **java.nio** 包及其子包下，并对原 **java.io** 包中很多的类进行改写
3. NIO 有三大核心部分：**Channel**（通道）、**Buffer**（缓冲区）、**Selector**（选择器）
4. NIO 是**面向缓冲区**，或者**面向块**编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络
5. Java NIO 的非阻塞模式，是一个线程从某通道发送请求或读取数据，但是它仅能得到目前可用的数据，如果目前没有可用的数据时，就什么也不会获取，而**不是保持线程阻塞状态**，所以直至数据变得可读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道时，不需要等待它完全写入，这个线程可以同时去做别的事情。
6. 通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有 10000 个请求过来，根据实际情况，可以分配 50 或 100 个线程来处理。不像之前的阻塞 IO 那样，必须要分配 10000 个线程来处理。
7. HTTP 2.0 使用了多路复用的技术，做到同时一个连接并发处理多个请求，而且并发请求的数量比 HTTP 1.1 大了几个数量级。





![s](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh5dbozjztj31bo0n6wwc.jpg)



#### NIO 三大核心原理示意图

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5jucyv11j30ee0j243w.jpg" alt="image-20200727151236782" style="zoom:67%;" />

1. 每个 channel 都会对应一个Buffer
2. Selector 对应一个线程，一个线程对应多个 channel（连接）
3. 该图反映了有三个 channel 注册到该 selector 程序
4. 程序切换到哪个 channel 是由事件决定的 ，Event 就是一个重要的概念
5. Selector 会根据不同的事件，在各个通道上切换
6. Buffer 就是一个内存块，底层是一个数组 
7. 数据的读写是通过 Buffer，这个和 BIO 有本质区别。在 BIO 中要么是输入流，要么是输出流，不能双向，但是NIO 中的 Buffer 是可以读也可以写，需要`flip`方法切换
8. channel 是双向的，可以反映底层操作系统的情况，比如 Linux 中，底层操作系统的通道就是双向的





### AIO

> 异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长。

### BIO、NIO、AIO 适用场景分析

1.  BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序简单易理解。

2.  NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。 编程比较复杂，JDK1.4 开始支持。
3. AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作， 编程比较复杂，JDK7 开始支持。



### BIO、NIO、AIO 对比表

![image-20200803101134180](https://tva1.sinaimg.cn/large/007S8ZIlly1ghdeh9za2zj31820ko1kx.jpg)