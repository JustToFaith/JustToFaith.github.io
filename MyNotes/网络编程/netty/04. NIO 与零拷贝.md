# NIO 与零拷贝



### 传统 IO 模型

> 四次拷贝，三次切换。

![image-20200803093647663](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghddh24sdsj31bk0kugwf.jpg)

DMA：direct memory access 直接内存拷贝（不使用 CPU）



### mmap 优化

> 三次拷贝，三次切换

1. mmap 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。

   示意图：

   ![image-20200803094231645](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghddn0veb5j317k0j27d6.jpg)



### sendFile 优化

> 三次拷贝，两次切换

1. Linux 2.1 版本 提供了 sendFile 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到

   Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。

   示意图：

   ![image-20200803094953556](https://tva1.sinaimg.cn/large/007S8ZIlly1ghdduoln66j31500ky7dw.jpg)

零拷贝：从操作系统角度，是没有 CPU拷贝

2. Linux 在 2.4 版本中，做了一些修改，避免了从内核缓冲区拷贝到 Socket buffer 的操作，直接拷贝到协议栈， 从而再一次减少了数据拷贝。具体如下图和小结：

   示意图：

   ![image-20200803095215370](https://tva1.sinaimg.cn/large/007S8ZIlly1ghddx58pzsj310g0kqjzk.jpg)

   这里其实有 一次 cpu 拷贝 kernel buffer -> socket buffer 但是，拷贝的信息很少，比如 lenght , offset , 消耗低，可以忽略。



### 零拷贝的理解

1. 我们说的零拷贝是从**操作系统的角度**来说的，因为内核缓冲区之间，没有数据是重复的（只用 kernel buffer有一份数据）。
2. 零拷贝不仅仅带来了更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 CPU 缓存伪共享以及无 CPU 校验和计算。



### mmap 和 sendFile 的区别

1. mmap 适合小数据量读写，sendFile 适合大文件传输。
2. mmap 需要四次上下文切换，3 次数据拷贝；sendFile 需要三次上下文切换，最少两次数据拷贝。
3. sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）

