# Buffer、Channel Selector



## Buffer

> 缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成一个**容器对象（含数组）**，该对象提供了**一组方法**，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须由 Buffer，如图：

![image-20200728084847469](https://tva1.sinaimg.cn/large/007S8ZIlly1gh6ed9m7exj30wq06cdiy.jpg)

#### Buffer 的属性

![image-20200728094612801](https://tva1.sinaimg.cn/large/007S8ZIlly1gh6g10dp7cj30qm0d479k.jpg)

#### Buffer 的相关方法

![image-20200728094707017](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6g1y7vl6j314y0oskjl.jpg)

#### ByteBuffer

![image-20200728094747817](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6g2npgyrj30yc0dmaxs.jpg)





## Channel

### 基本介绍

1. NIO 的通道类似于流，但有区别如下：
   - 通道可以同时进行读写，而流只能读或者只能写
   - 通道可以实现异步读写数据
   - 通道可以从缓冲读数据，也可以写数据到缓存
2. BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道（Channel）是双向的，可以读操作，也可以写操作
3. Channel 在 NIO 中是一个接口`public interface Channel extends Closeable{}`
4. 常用的 Channel 类有：FileChannel、DatagramChannel、ServerSocketChannel（类似 ServerSocket） 和 SocketChannel（类似 Socket）
5. FileChannel 用于文件的数据读写，DatagramChannel用于 UDP 的数据读写，ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写



### FileChannel 类

> FileChannel IO 操作

常见的方法：

- public int read(ByteBuffer dst)，从通道读取数据并放到缓冲区
- public int write(ByteBuffer src)，把缓冲区的数据写到通道中
- public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道中复制数据到当前通道
- public long transferTo(long position, long count, WritableByteChannel target)，把数据从当前通道复制给目标通道



### Buffer 和 Channel 的注意事项

1. ByteBuffer 支持类型化的 put 和 get，put 放入的什么类型数据，get 就应该使用相应的数据类型来取出，否则可能有 BufferUnderflowException 异常。

2. 可以将一个不同的 Buffer 转成只读 Buffer。`buffer.asReadOnlyBuffer()`

3. NIO 还提供了 MappedByteBuffer，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 NIO 来完成。

   MappedByteBuffer 可以让文件直接在**内存中修改**，操作系统不需要拷贝一次。

4. 前面的几个读写操作都是通过一个Buffer 完成的，NIO 还支持通过多个 Buffer（即 Buffer 数组）完成读写操作，即 Scattering 和 Gathering。





### Selector

#### 基本介绍

1. java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个客户端的连接，就是使用到**Selector（选择器）**
2. **Selector 能够检测多个注册的通道上是否有时间发生（注意：多个 Channel 以事件的方式可以注册到同一个 Selector）**，如果有事件发生，便获取事件，然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。
3. 只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。
4. 避免了多线程之间的上下文切换导致的开销。



#### Selector 示意图和特点说明

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7olky3ykj30j40i243t.jpg" alt="image-20200729112820209" style="zoom:50%;" />

##### 特点说明

1. Netty 的 IO 线程 NioEventLoop 聚合了 Selector（选择器，也叫多路复用器），可以同时并发处理成千上万客户端的连接。
2. 当线程从某个客户端 socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。
3. 线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。
4. 由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 IO 阻塞导致的线程挂起。
5. 一个 IO 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 IO 一连接一线程模型，架构的性能、弹性伸缩力和可靠性都得到了极大的提升。



#### Selector 类相关方法

Selector 类是一个抽象类，常用和说明如下：

![image-20200729113715368](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7ouv9k7oj31260bek9d.jpg)

##### Selector 相关方法说明：

- `selector.select()`阻塞
- `selector.select(1000)` 阻塞 1000 毫秒，在 1000 毫秒后返回
- `selector.wakeup()`唤醒 selector
- `selector.selectNow`不阻塞，立马返回

