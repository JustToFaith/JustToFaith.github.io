#### Tensorflow的索引

- Basic indexing 

  - [idx]\[idx][idx]

    这种方式比较麻烦，可读性较差

- Same with Numpy

  - [idx,idx,....]

    a[1,2,3,4]

    这种方式是numpy的读取方式，可读性较好。推荐使用

  - start:end

    a[0:-1]

  - `start:end:step`

  - a[:,:,:,1]

    这个方式为索引提供了更多的方式，如果没有`:`，则不能索引前面几个要，而之后几个取其中一部分的情况。

  - a[1:\-1:2​,,,]

  - ...

    a[0,...]当前面纬度索引和切片的时候，如果后面的纬度都没有变化，采用默认序列。则之后的纬度都都可以用`...`来表示。当然，`...`也可以放到前面，或者中间，前提是必须要将需要前面或者后面几个有切片或者索引的表示出来。



#### Selective Index

> 用下面数据进行解释：data:[classes,students, subjects]   4,35,8

- tf.gather

  ```python
  a = tf.tensor([4, 35, 8])
  # 选取3和4两个班级，查看他们的学生和成绩
  tf.gather(a, axis=0, indices=[2,3])    # axis是选取哪个纬度，axis=0是选取班级纬度，indices是对那个纬度操作的范围
  # 上面的操作也可以通过numpy的方式进行操作，但是如果选择的顺序不是顺序也不是逆序，而是乱序就不能通过numpy的方法，可以采用如下方法
  tf.gather(a, axis=0, indices=[2,1,3,0])    # 这个操作就是先选择2班，然后选择1班，之后选择3班，最后选择1班的顺序   
  ```

  

- tf.gather_nd

  对多个纬度同时操作

- tf.boolean_mask

  表示对True取，对False不取
  
  ```python
  a.shape
  TensorShape([4,28,28,3])
  
  tf.boolean_mask(a,mask=[Ture,True,False],axis=3).shape
  TensorShape([4,28,28,2]) #对最后一个维度取了两个
  
  tf.ones([2,3,4])
  <tf.Tensor: shape=(2, 3, 4), dtype=float32, numpy=
  array([[[1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.]],
  
         [[1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.]]], dtype=float32)>
  
  tf.boolean_mask(a,mask=[[True,False,False],[False,True,True]])
  <tf.Tensor: shape=(3, 4), dtype=float32, numpy=
  array([[1., 1., 1., 1.],
         [1., 1., 1., 1.],
         [1., 1., 1., 1.]], dtype=float32)>
  
  # mask后面的数组可以看成是一个3*4的矩阵，对应着a[2,3,4]的前面两个维度
  # 第一个为True得到一个[4],最后两个为Ture得到两个[4]，最后合起来就是
  # [[4],[4],[4]] 所以最后合起来得到一个3*4的矩阵
  
  ```
  
  
  
  
  
  